æ”¯ä»˜ç¡®å®å¤æ‚ï¼ğŸ˜… ç‰¹åˆ«æ˜¯å¾®ä¿¡æ”¯ä»˜ï¼Œå„ç§å‚æ•°ã€ç­¾åã€å›è°ƒéªŒè¯ï¼Œä¸€ä¸å°å¿ƒå°±è¸©å‘ã€‚

## ğŸ¯ æ ¸å¿ƒæ€è·¯å…¶å®å¾ˆç®€å•

### 1. **æ”¯ä»˜çš„æœ¬è´¨**

```
ç”¨æˆ· â†’ å‰ç«¯ â†’ åå° â†’ æ”¯ä»˜å¹³å° â†’ å›è°ƒ â†’ åå° â†’ ä¸šåŠ¡é€»è¾‘
```

### 2. **ä½ åªéœ€è¦å…³å¿ƒä¸¤ä¸ªåœ°æ–¹**

```
// 1. ç”Ÿæˆæ”¯ä»˜å‚æ•°æ—¶ï¼ˆå‰ç«¯è°ƒæ”¯ä»˜ï¼‰
public Map<String, String> createPayParams(Order order) {
    // è®¡ç®—ç­¾åè¿”å›ç»™å‰ç«¯
}

// 2. éªŒè¯æ”¯ä»˜å›è°ƒæ—¶ï¼ˆå¾®ä¿¡/æ”¯ä»˜å®å›è°ƒä½ ï¼‰
public boolean verifyCallback(PaymentCallback callback) {
    // éªŒè¯ç­¾åæ˜¯å¦æ­£ç¡®
}
```

### 3. **ç­¾åéªŒè¯çš„æ ¸å¿ƒä»£ç **

```
// çœŸçš„å°±è¿™ä¹ˆç®€å•
public boolean verifyWechatSign(Map<String, String> params, String mchKey) {
    // 1. å¯¹å‚æ•°æŒ‰keyæ’åº
    // 2. æ‹¼æˆå­—ç¬¦ä¸²: key1=value1&key2=value2&...&key=n
    // 3. æœ€ååŠ ä¸Š: &key=å•†æˆ·å¯†é’¥
    // 4. è®¡ç®—MD5ï¼Œè½¬å¤§å†™
    // 5. å¯¹æ¯”è¿”å›çš„ç­¾å
    
    return generatedSign.equals(receivedSign);
}
```

## ğŸ“ æœ€ç®€å•çš„å®ç°

```
package com.aioveu.pay.aioveu00Payment.utils;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.util.DigestUtils;
import org.springframework.util.StringUtils;

import java.nio.charset.StandardCharsets;
import java.util.Map;
import java.util.TreeMap;

/**
 * æ”¯ä»˜ç­¾åéªŒè¯å·¥å…·
 */
@Slf4j
@Component
public class PaymentSignUtil {
    
    @Value("${pay.wechat.mch-key:}")
    private String wxMchKey;  // å¾®ä¿¡å•†æˆ·å¯†é’¥
    
    @Value("${pay.alipay.public-key:}")
    private String aliPublicKey;  // æ”¯ä»˜å®å…¬é’¥
    
    /**
     * éªŒè¯å¾®ä¿¡æ”¯ä»˜å›è°ƒç­¾å
     */
    public boolean verifyWechat(Map<String, String> params) {
        try {
            // 1. ä»å›è°ƒå‚æ•°ä¸­è·å–ç­¾å
            String receivedSign = params.get("sign");
            if (StringUtils.isEmpty(receivedSign)) {
                log.error("å¾®ä¿¡å›è°ƒæ— ç­¾å");
                return false;
            }
            
            // 2. é‡æ–°è®¡ç®—ç­¾å
            String generatedSign = calculateWechatSign(params, wxMchKey);
            
            // 3. å¯¹æ¯”
            boolean ok = receivedSign.equals(generatedSign);
            
            if (!ok) {
                log.error("å¾®ä¿¡ç­¾åä¸åŒ¹é…ï¼Œæ¥æ”¶: {}, è®¡ç®—: {}", receivedSign, generatedSign);
            }
            
            return ok;
            
        } catch (Exception e) {
            log.error("å¾®ä¿¡ç­¾åéªŒè¯å¼‚å¸¸", e);
            return false;
        }
    }
    
    /**
     * è®¡ç®—å¾®ä¿¡ç­¾å
     */
    private String calculateWechatSign(Map<String, String> params, String mchKey) {
        // 1. æŒ‰keyæ’åº
        Map<String, String> sorted = new TreeMap<>(params);
        
        // 2. æ‹¼æ¥å­—ç¬¦ä¸²
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, String> entry : sorted.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();
            
            // è·³è¿‡ç©ºå€¼å’Œsignå­—æ®µ
            if (!"sign".equals(key) && StringUtils.hasText(value)) {
                if (sb.length() > 0) sb.append("&");
                sb.append(key).append("=").append(value);
            }
        }
        
        // 3. åŠ ä¸Škey
        sb.append("&key=").append(mchKey);
        
        // 4. è®¡ç®—MD5ï¼Œè½¬å¤§å†™
        String signStr = sb.toString();
        String md5 = DigestUtils.md5DigestAsHex(signStr.getBytes(StandardCharsets.UTF_8));
        
        return md5.toUpperCase();
    }
}
```

## ğŸ® åœ¨Controllerä¸­ä½¿ç”¨

```
@RestController
@RequestMapping("/api/pay")
@RequiredArgsConstructor
public class PayCallbackController {
    
    private final PaymentSignUtil paymentSignUtil;
    
    /**
     * å¾®ä¿¡æ”¯ä»˜å›è°ƒ
     */
    @PostMapping("/callback/wechat")
    public String wechatCallback(@RequestBody String xmlData) {
        log.info("æ”¶åˆ°å¾®ä¿¡æ”¯ä»˜å›è°ƒ: {}", xmlData);
        
        try {
            // 1. è§£æXML
            Map<String, String> params = parseXml(xmlData);
            
            // 2. éªŒè¯ç­¾å
            if (!paymentSignUtil.verifyWechat(params)) {
                return "<xml><return_code><![CDATA[FAIL]]></return_code><return_msg><![CDATA[ç­¾åé”™è¯¯]]></return_msg></xml>";
            }
            
            // 3. è·å–è®¢å•å·
            String orderNo = params.get("out_trade_no");
            
            // 4. æŸ¥è¯¢è®¢å•
            Order order = orderService.getByOrderNo(orderNo);
            if (order == null) {
                return "<xml><return_code><![CDATA[FAIL]]></return_code><return_msg><![CDATA[è®¢å•ä¸å­˜åœ¨]]></return_msg></xml>";
            }
            
            // 5. å¤„ç†æ”¯ä»˜æˆåŠŸé€»è¾‘
            if ("SUCCESS".equals(params.get("result_code"))) {
                // æ›´æ–°è®¢å•çŠ¶æ€
                orderService.paySuccess(orderNo, params.get("transaction_id"));
            }
            
            // 6. è¿”å›æˆåŠŸ
            return "<xml><return_code><![CDATA[SUCCESS]]></return_code><return_msg><![CDATA[OK]]></return_msg></xml>";
            
        } catch (Exception e) {
            log.error("å¤„ç†å¾®ä¿¡å›è°ƒå¼‚å¸¸", e);
            return "<xml><return_code><![CDATA[FAIL]]></return_code><return_msg><![CDATA[ç³»ç»Ÿå¼‚å¸¸]]></return_msg></xml>";
        }
    }
    
    /**
     * ç®€å•è§£æXML
     */
    private Map<String, String> parseXml(String xml) {
        Map<String, String> map = new HashMap<>();
        // è¿™é‡Œç®€åŒ–ï¼Œå®é™…åº”è¯¥ç”¨XMLè§£æåº“
        // å¾®ä¿¡å›è°ƒæ˜¯XMLæ ¼å¼: <xml><out_trade_no>123</out_trade_no><sign>xxx</sign></xml>
        
        // ç®€å•å®ç°ï¼ŒæŒ‰æ­£åˆ™æå–
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("<([^>]+)>([^<]+)</\\1>");
        java.util.regex.Matcher matcher = pattern.matcher(xml);
        while (matcher.find()) {
            map.put(matcher.group(1), matcher.group(2));
        }
        
        return map;
    }
}
```

## ğŸ’¡ å®é™…å¼€å‘ä¸­çš„ç»éªŒ

### 1. **ä¸€å®šè¦æœ‰çš„æ—¥å¿—**

```
// åœ¨å…³é”®åœ°æ–¹åŠ æ—¥å¿—
log.info("ã€æ”¯ä»˜å›è°ƒã€‘æ”¶åˆ°å›è°ƒï¼Œè®¢å•å·: {}, é‡‘é¢: {}, çŠ¶æ€: {}", 
    orderNo, amount, status);

log.info("ã€æ”¯ä»˜å›è°ƒã€‘ç­¾åéªŒè¯: {}", signValid ? "æˆåŠŸ" : "å¤±è´¥");

log.info("ã€æ”¯ä»˜å›è°ƒã€‘è®¢å•çŠ¶æ€æ›´æ–°: {}", success ? "æˆåŠŸ" : "å¤±è´¥");
```

### 2. **ä¸€å®šè¦åšçš„éªŒè¯**

```
// 1. éªŒè¯ç­¾å
if (!verifySign()) {
    return "FAIL";  // ä¸€å®šè¦è¿”å›å¤±è´¥
}

// 2. éªŒè¯è®¢å•æ˜¯å¦å­˜åœ¨
if (order == null) {
    return "FAIL";
}

// 3. éªŒè¯é‡‘é¢ï¼ˆé˜²æ­¢1åˆ†æ”¯ä»˜1ä¸‡å…ƒï¼‰
BigDecimal callbackAmount = new BigDecimal(params.get("total_fee")).divide(new BigDecimal("100"));
if (order.getAmount().compareTo(callbackAmount) != 0) {
    log.error("é‡‘é¢ä¸åŒ¹é…ï¼Œè®¢å•: {}, å›è°ƒ: {}", order.getAmount(), callbackAmount);
    return "FAIL";
}

// 4. å¹‚ç­‰æ€§å¤„ç†ï¼ˆé˜²æ­¢é‡å¤å›è°ƒï¼‰
if (order.isPaid()) {
    log.info("è®¢å•å·²æ”¯ä»˜ï¼Œè·³è¿‡å¤„ç†");
    return "SUCCESS";  // å·²æ”¯ä»˜ä¹Ÿè¦è¿”å›æˆåŠŸ
}
```

### 3. **é…ç½®æ–‡ä»¶**

```
# æ”¯ä»˜é…ç½®
pay:
  wechat:
    mch-key: ä½ çš„å•†æˆ·å¯†é’¥  # åœ¨å¾®ä¿¡å•†æˆ·å¹³å°è·å–
  alipay:
    public-key: ä½ çš„æ”¯ä»˜å®å…¬é’¥
  notify-url: https://ä½ çš„åŸŸå.com/api/pay/callback/wechat
```

## ğŸ†˜ è°ƒè¯•æŠ€å·§

1. 

   **æœ¬åœ°æµ‹è¯•ç”¨å†…ç½‘ç©¿é€**

   - ç”¨ ngrokã€frp ç­‰å·¥å…·
   - æŠŠå›è°ƒåœ°å€é…æˆ `https://ä½ çš„åŸŸå.ngrok.io/api/pay/callback`

2. **æ—¥å¿—æ‰“å°å›è°ƒæ•°æ®**

   ```
   log.info("å¾®ä¿¡å›è°ƒåŸå§‹æ•°æ®: {}", xmlData);
   log.info("è§£æåå‚æ•°: {}", params);
   ```

3. **ç­¾åä¸ä¸€è‡´æ—¶æ‰“å°è®¡ç®—è¿‡ç¨‹**

   ```
   log.info("å¾…ç­¾åå­—ç¬¦ä¸²: {}", signStr);
   log.info("è®¡ç®—ç­¾å: {}, æ”¶åˆ°ç­¾å: {}", generatedSign, receivedSign);
   ```

## ğŸ¯ æ€»ç»“

å…¶å®æ”¯ä»˜çš„æ ¸å¿ƒå°±ä¸¤ç‚¹ï¼š

1. **ç”Ÿæˆæ”¯ä»˜å‚æ•°æ—¶**ï¼šæŒ‰è§„åˆ™è®¡ç®—ç­¾å
2. **æ”¶åˆ°å›è°ƒæ—¶**ï¼šéªŒè¯ç­¾åæ˜¯å¦æ­£ç¡®

å…¶ä»–éƒ½æ˜¯ä¸šåŠ¡é€»è¾‘ã€‚ä½ å…ˆå®ç°ç­¾åéªŒè¯ï¼Œå…¶ä»–çš„æ…¢æ…¢æ¥ï¼æœ‰é—®é¢˜éšæ—¶é—®æˆ‘ã€‚ğŸ˜„