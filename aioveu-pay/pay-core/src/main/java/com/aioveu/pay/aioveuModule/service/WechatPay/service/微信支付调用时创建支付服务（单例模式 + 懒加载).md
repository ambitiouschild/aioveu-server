这是一个很好的架构设计问题。让我详细分析两种方案的优劣：

## 方案对比

### 方案1：调用时创建（懒加载）

```
public PaymentParamsVO jsapiPay(PaymentRequestDTO request) {
    // 每次调用都创建新的服务和配置
    com.wechat.pay.java.core.Config config = wechatPayConfig.toSdkConfig();
    JsapiService jsapiService = new JsapiService.Builder().config(config).build();
    // ...
}
```

**优点**：

- ✅ 简单直接，无状态问题
- ✅ 内存占用小（用完后可被GC回收）
- ✅ 避免初始化失败导致整个服务不可用
- ✅ 便于调试和测试

**缺点**：

- ❌ 性能较差（每次都要创建对象）
- ❌ 重复加载私钥文件
- ❌ 可能触发微信支付证书下载多次
- ❌ 连接池无法复用

### 方案2：启动时全部初始化

```
@PostConstruct
public void init() {
    com.wechat.pay.java.core.Config config = wechatPayConfig.toSdkConfig();
    this.jsapiService = new JsapiService.Builder().config(config).build();
    this.appService = new AppService.Builder().config(config).build();
    this.h5Service = new H5Service.Builder().config(config).build();
    this.refundService = new RefundService.Builder().config(config).build();
}
```

**优点**：

- ✅ 性能好（只初始化一次）
- ✅ 复用连接池
- ✅ 避免重复加载证书
- ✅ 内存中保持长连接

**缺点**：

- ❌ 启动时间长
- ❌ 如果初始化失败，整个支付功能不可用
- ❌ 内存占用高
- ❌ 配置更新需要重启

## 推荐方案：单例模式 + 懒加载

### 方案3：单例模式（最佳实践）

```
@Service
@Slf4j
public class WeChatPayServiceImpl implements WeChatPayService {

    private final WeChatPayConfig wechatPayConfig;
    private final WeChatPayRequestFactory requestFactory;
    
    // 使用 volatile 保证可见性
    private volatile com.wechat.pay.java.core.Config sdkConfig;
    private volatile JsapiService jsapiService;
    private volatile AppService appService;
    private volatile H5Service h5Service;
    private volatile RefundService refundService;

    @Autowired
    public WeChatPayServiceImpl(WeChatPayConfig wechatPayConfig,
                                WeChatPayRequestFactory requestFactory) {
        this.wechatPayConfig = wechatPayConfig;
        this.requestFactory = requestFactory;
    }
    
    /**
     * 获取SDK配置（单例）
     */
    private com.wechat.pay.java.core.Config getSdkConfig() {
        if (sdkConfig == null) {
            synchronized (this) {
                if (sdkConfig == null) {
                    log.info("【微信支付】创建SDK配置");
                    sdkConfig = wechatPayConfig.toSdkConfig();
                }
            }
        }
        return sdkConfig;
    }
    
    /**
     * 获取JSAPI服务（单例）
     */
    private JsapiService getJsapiService() {
        if (jsapiService == null) {
            synchronized (this) {
                if (jsapiService == null) {
                    log.info("【微信支付】初始化JSAPI服务");
                    jsapiService = new JsapiService.Builder()
                            .config(getSdkConfig())
                            .build();
                }
            }
        }
        return jsapiService;
    }
    
    /**
     * 获取APP服务（单例）
     */
    private AppService getAppService() {
        if (appService == null) {
            synchronized (this) {
                if (appService == null) {
                    log.info("【微信支付】初始化APP服务");
                    appService = new AppService.Builder()
                            .config(getSdkConfig())
                            .build();
                }
            }
        }
        return appService;
    }
    
    // 其他服务类似...
    
    @Override
    public PaymentParamsVO jsapiPay(PaymentRequestDTO request) {
        // 使用单例服务
        JsapiService service = getJsapiService();
        // ...
    }
}
```

## 方案4：工厂模式（更灵活）

```
@Component
@Slf4j
public class WeChatPayClientFactory {
    
    @Autowired
    private WeChatPayConfig weChatPayConfig;
    
    // 单例配置
    private volatile com.wechat.pay.java.core.Config config;
    
    // 服务缓存
    private final Map<String, Object> serviceCache = new ConcurrentHashMap<>();
    
    /**
     * 获取配置（单例）
     */
    public com.wechat.pay.java.core.Config getConfig() {
        if (config == null) {
            synchronized (this) {
                if (config == null) {
                    config = createConfig();
                }
            }
        }
        return config;
    }
    
    /**
     * 获取JSAPI服务
     */
    public JsapiService getJsapiService() {
        return (JsapiService) serviceCache.computeIfAbsent("jsapi", key -> {
            log.info("创建JSAPI服务");
            return new JsapiService.Builder()
                    .config(getConfig())
                    .build();
        });
    }
    
    /**
     * 获取APP服务
     */
    public AppService getAppService() {
        return (AppService) serviceCache.computeIfAbsent("app", key -> {
            log.info("创建APP服务");
            return new AppService.Builder()
                    .config(getConfig())
                    .build();
        });
    }
    
    // 其他服务...
    
    /**
     * 重新加载配置（热更新）
     */
    public synchronized void reloadConfig() {
        log.info("重新加载微信支付配置");
        config = null;
        serviceCache.clear();
    }
}
```

## 性能测试对比

假设 QPS=100，运行1小时：

| 方案                | 总创建次数 | 内存占用 | 响应时间    | 适用场景             |
| ------------------- | ---------- | -------- | ----------- | -------------------- |
| 方案1（每次创建）   | 360,000次  | 低       | 慢（~50ms） | 低频访问、测试环境   |
| 方案2（启动初始化） | 1次        | 高       | 快（~5ms）  | 高性能要求、生产环境 |
| 方案3（单例懒加载） | 4次        | 中       | 快（~5ms）  | 通用场景、推荐使用   |
| 方案4（工厂模式）   | 4次        | 中       | 快（~5ms）  | 需要热更新、复杂场景 |

## 微信支付SDK的特殊性

微信支付 SDK 的内部机制需要考虑：

1. **证书管理**：SDK 会自动下载和缓存微信支付平台证书
2. **连接池**：HTTP 连接可以复用
3. **签名计算**：RSA 签名比较耗时
4. **配置验证**：启动时验证配置有效性

## 我的建议

### 针对你的场景，我推荐**方案3（单例懒加载）**

**实现代码**：

```
@Service
@Slf4j
public class WeChatPayServiceImpl implements WeChatPayService {

    private final WeChatPayConfig wechatPayConfig;
    private final WeChatPayRequestFactory requestFactory;
    
    // 单例实例
    private volatile com.wechat.pay.java.core.Config sdkConfig;
    private volatile JsapiService jsapiService;
    private volatile AppService appService;
    private volatile H5Service h5Service;
    private volatile RefundService refundService;

    @Autowired
    public WeChatPayServiceImpl(WeChatPayConfig wechatPayConfig,
                                WeChatPayRequestFactory requestFactory) {
        this.wechatPayConfig = wechatPayConfig;
        this.requestFactory = requestFactory;
        
        // 可选：在启动时预加载常用服务
        preloadCommonServices();
    }
    
    /**
     * 预加载常用服务（可选）
     */
    private void preloadCommonServices() {
        // 根据业务情况预加载
        if (wechatPayConfig.isPreloadEnabled()) {
            new Thread(() -> {
                try {
                    log.info("【微信支付】预加载常用服务...");
                    // 预加载JSAPI和APP服务（最常用）
                    getJsapiService();
                    getAppService();
                    log.info("【微信支付】预加载完成");
                } catch (Exception e) {
                    log.warn("【微信支付】预加载失败，不影响正常使用", e);
                }
            }).start();
        }
    }
    
    /**
     * 获取SDK配置（单例+双重检查锁）
     */
    private com.wechat.pay.java.core.Config getSdkConfig() {
        if (sdkConfig == null) {
            synchronized (this) {
                if (sdkConfig == null) {
                    log.info("【微信支付】初始化SDK配置");
                    sdkConfig = createSdkConfig();
                }
            }
        }
        return sdkConfig;
    }
    
    /**
     * 创建SDK配置
     */
    private com.wechat.pay.java.core.Config createSdkConfig() {
        try {
            return wechatPayConfig.toSdkConfig();
        } catch (Exception e) {
            log.error("【微信支付】创建SDK配置失败", e);
            throw new RuntimeException("微信支付配置初始化失败", e);
        }
    }
    
    /**
     * 获取JSAPI服务
     */
    private JsapiService getJsapiService() {
        if (jsapiService == null) {
            synchronized (this) {
                if (jsapiService == null) {
                    log.info("【微信支付】初始化JSAPI服务");
                    jsapiService = new JsapiService.Builder()
                            .config(getSdkConfig())
                            .build();
                }
            }
        }
        return jsapiService;
    }
    
    // 其他服务类似...
    
    /**
     * 在支付方法中直接使用
     */
    @Override
    public PaymentParamsVO jsapiPay(PaymentRequestDTO request) {
        try {
            // 使用单例服务
            JsapiService service = getJsapiService();
            
            // 构建请求
            com.wechat.pay.java.service.payments.jsapi.model.PrepayRequest prepayRequest =
                    requestFactory.createJsapiRequest(request, wechatPayConfig);
            
            // 调用支付
            com.wechat.pay.java.service.payments.jsapi.model.PrepayResponse response =
                    service.prepay(prepayRequest);
            
            // 处理结果...
            
        } catch (Exception e) {
            // 异常处理...
        }
    }
}
```

## 配置建议

```
wechat:
  pay:
    # 基本配置
    mch-id: xxx
    mch-serial-no: xxx
    api-v3-key: xxx
    private-key-path: classpath:apiclient_key.pem
    app-id: xxx
    
    # 性能配置
    preload-enabled: true     # 是否预加载
    connection-timeout: 5000  # 连接超时(ms)
    read-timeout: 10000       # 读取超时(ms)
    
    # 高级配置
    auto-update-cert: true    # 自动更新证书
    cert-update-interval: 3600 # 证书更新间隔(秒)
```

## 结论

**推荐使用单例懒加载（方案3）**，因为它：

1. **性能好**：避免重复创建
2. **稳定性高**：懒加载避免启动失败
3. **内存友好**：按需加载
4. **代码简洁**：易于维护
5. **扩展性好**：便于添加新功能

不要选择"每次调用都创建"，因为微信支付涉及证书加载、签名计算等耗时操作，频繁创建会影响性能。