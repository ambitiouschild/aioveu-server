根据你提供的 `PermissionService`，我理解你的权限校验逻辑是基于 Redis 中存储的角色权限数据。现在，我们需要将 system 服务配置为资源服务器，并使用 JWT 进行认证，同时保留你现有的权限校验逻辑。

关键点：

1. 在 system 服务中，我们将使用 JWT 令牌，其中包含用户角色和权限信息。

  2.你现有的 `PermissionService`从 Redis 中获取角色对应的权限，然后进行校验。

3.我们需要在 JWT 中包含用户角色，以便在 system 服务中获取当前用户的角色。

但是，注意：在资源服务器（system）中，我们通常从 JWT 中直接获取权限（authorities），而不是从 Redis 中获取。因为 Redis 可能是在认证服务（auth）中存储的，而 system 服务可能无法直接访问 auth 服务的 Redis（除非共享 Redis）。

有两种方案：

方案一：在 JWT 中直接包含权限信息（推荐，符合无状态设计）

方案二：在 system 服务中通过 Redis 获取权限（需要共享 Redis，且可能带来网络开销）

根据你提供的 `PermissionService`，你目前使用的是方案二（从 Redis 获取）。但是，为了符合 OAuth2 资源服务器的最佳实践，我建议采用方案一，即将权限信息放在 JWT 中。

不过，既然你已经有从 Redis 获取权限的逻辑，我们可以保留，但需要调整：

1. 在 auth 服务中，颁发 JWT 时，将用户权限放入 JWT 的 `authorities`声明中。
2. 在 system 服务中，从 JWT 中提取权限，并设置到 `SecurityContext`中。

这样，你的 `PermissionService`就可以从 `SecurityContext`中获取权限，而不需要从 Redis 获取。

但是，如果你确实需要从 Redis 获取（比如权限数据较大，JWT 令牌过长），那么我们可以保留现有逻辑。

鉴于你现有的代码，我假设你希望继续从 Redis 获取权限。那么我们需要在 system 服务中配置一个 `JwtAuthenticationConverter`，从 JWT 中提取角色（而不是权限），因为你的 `PermissionService`是需要角色代码（roleCodes）来查询权限的。

步骤：

1. 

   在 auth 服务中，颁发 JWT 时，将用户角色放入 JWT 的 `roles`声明中。

2. 

   在 system 服务中，配置一个 `JwtAuthenticationConverter`，从 JWT 的 `roles`声明中提取角色，并转换为 `GrantedAuthority`。

3. 

   在 system 服务中，`PermissionService`通过 `SecurityUtils.getRoles()`获取当前用户的角色，然后从 Redis 获取权限。

但是，注意：你的 `PermissionService`的 `hasPerm`方法需要的是权限字符串，而你现在是从 Redis 中根据角色获取权限。所以，我们仍然需要从 Redis 中获取权限。

注意：你需要确保 auth 服务在颁发 JWT 时，在 JWT 中包含一个 `roles`声明，其中包含用户角色列表。

假设你的 JWT 负载（payload）类似这样：

{

"sub": "username",

"roles": ["ROLE_ADMIN", "ROLE_USER"]

}

在 system 服务中，我们将配置一个 `JwtAuthenticationConverter`，将 `roles`声明转换为 `GrantedAuthority`。